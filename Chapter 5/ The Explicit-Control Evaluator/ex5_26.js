let marker_position = null;
function push_marker() { marker_position = stack.length; }
function pop_marker() {
    if (marker_position === null) {
        throw new Error("No marker on stack");
    } else {
        stack.length = marker_position;
        marker_position = null;
    }
}
function push_while_marker() { push_marker(); }
function push_while_body_start_marker() { push_marker(); }
function pop_to_while_marker() { pop_marker(); }
function pop_to_while_body_start_marker() { pop_marker(); }

controller(
    [
    "eval-dispatch",
        test([op("is_literal"), reg("comp")]),
        branch(label("ev_literal")),
        test([op("is_name"), reg("comp")]),
        branch(label("ev_name")),
        test([op("is_application"), reg("comp")]),
        branch(label("ev_application")),
        test([op("is_operator_conditional"), reg("comp")]),
        branch(label("ev_operator_conditional")),
        test([op("is_conditional"), reg("comp")]),
        branch(label("ev_conditional")),
        test([op("is_lambda"), reg("comp")]),
        branch(label("ev_lambda")),
        test([op("is_sequence"), reg("comp")]),
        branch(label("ev_sequence")),
        test([op("is_block"), reg("comp")]),
        branch(label("ev_block")),
        test([op("is_return_statement"), reg("comp")]),
        branch(label("ev_return")),
        test([op("is_function_declaration"), reg("comp")]),
        branch(label("ev_function_declaration")),
        test([op("is_declaration"), reg("comp")]),
        branch(label("ev_declaration")),
        test([op("is_assignment"), reg("comp")]),
        branch(label("ev_assignment")),
        go_to(label("unknown_compression_type")),
        test([op("is_while"), reg("comp")]),
        branch(label("ev_while")),
        test([op("is_break"), reg("comp")]),
        branch(label("ev_break")),
        test([op("is_continue"), reg("comp")]),
        branch(label("ev_continue")),
        // ex 5.26
        test([op("is_thunk"), reg("comp")]),
        branch(label("ev_thunk")),
    "ev_literal",
        assign("val", [op("literal_value"), reg("comp")]),
        go_to(reg("continue")),
    "ev_name",
        assign("val", [op("symbol_of_name"), reg("comp"), reg("env")]),
        assign("val", [op("lookup_symbol_value"), reg("val"), reg("env")]),
        go_to(reg("continue")),
    "ev_lambda",
        assign("unev", [op("lambda_parameter_symobls"), reg("comp")]),
        assign("comp", [op("lambda_body"), reg("comp")]),
        assign("val", [op("make_function"), reg("unev"), reg("comp"), reg("env")]),
        go_to(reg("continue")),
    "ev_conditional",
        save(reg("comp")),
        save(reg("env")),
        save(reg("continue")),
        assign("continue", label("ev_conditional_decide")),
        assign("comp", [op("conditional_predicate"), reg("comp")]),
        go_to(label("eval_dispatch")),
    "ev_conditional_decide",
        restore(reg("continue")),
        restore(reg("env")),
        restore(reg("comp")),
        test([op("is_falsy"), reg("val")]),
        branch(label("ev_conditional_alternative")),
    "ev_conditional_consequent",
        assign("comp", [op("conditional_consequent"), reg("comp")]),
        go_to(label("eval_dispatch")),
    "ev_conditional_alternative",
        assign("comp", [op("conditional_alternative"), reg("comp")]),
        go_to(label("eval_dispatch")),
    "ev_sequence",
        assign("unev", [op("sequence_statements"), reg("comp")]),
        test([op("is_seqeuence_empty"), reg("unev")]),
        branch(label("ev_sequence_empty")),
        save("continue"),
    "ev_sequence_next",
        assign("comp", [op("first_statement"), reg("unev")]),
        test([op("is_last_statement"), reg("unev")]),
        branch(label("ev_sequence_last_statement")),
        save("unev"),
        save("env"),
        assign("continue", label("ev_sequence_continue")),
        go_to(label("eval_dispatch")),
    "ev_sequence_continue",
        restore("env"),
        restore("unev"),
        assign("unev", [op("rest_statements"), reg("unev")]),
        go_to(label("ev_sequence_next")),
    "ev_sequence_last_statement",
        restore("continue"),
        go_to(label("continue")),
    "ev_seqeuence_empty",
        assign("val", constant(undefined)),
        go_to(reg("continue")),
    "ev_operator_combination",
        assign("comp", [op("operator_combination_to_application"), reg("comp"), reg("env")]),
    // ex 5.26
    "ev_application",
        save("continue"),
        save("env"),
        assign("unev", [op("operands"), reg("comp")]),
        save("unev"),
        assign("comp", [op("operator"), reg("comp")]),
        assign("continue", label("ev_appl_did_function_expression")),
        go_to(label("eval_dispatch")),
    "ev_appl_did_function_expression",
        restore("unev"),
        restore("env"),
        assign("argl", [op("empty_arglist")]),
        assign("fun", reg("val")),
        test([op("is_null"), reg("unev")]),
        branch(label("apply_dispatch")),
        save("fun"),
    "ev_appl_lazy_operand_loop",
        save("argl"),
        assign("comp", [op("head"), reg("unev")]),
        assign("argl", [op("adjoin_arg_lazy"), reg("comp"), reg("env"), reg("argl")]),
        assign("unev", [op("tail"), reg("unev")]),
        go_to(label("ev_appl_lazy_operand_loop")),
    // end of ex 5.26
    "ev_appl_argument_expression_loop",
        save("argl"),
        assign("comp", [op("head"), reg("unev")]),
        test([op("is_last_argument_expression"), reg("unev")]),
        branch(label("ev_appl_last_arg")),
        save("env"),
        save("unev"),
        assign("continue", label("ev_appl_accumulate_arg")),
        go_to(label("eval_dispatch")),
    "ev_appl_accumulate_arg",
        restore("unev"),
        restore("env"),
        restore("argl"),
        assign("argl", [op("adjoin_arg"), reg("val"), reg("argl")]),
        assign("unev", [op("tail"), reg("unev")]),
        go_to(label("ev_appl_argument_expression_loop")),
    "ev_appl_last_arg",
        assign("continue", label("ev_appl_accum_last_arg")),
        go_to(label("eval_dispatch")),
    "ev_appl_accum_last_arg",
        restore("argl"),
        assign("argl", [op("adjoin_arg"), reg("val"), reg("argl")]),
        restore("fun"),
        go_to(label("apply_dispatch")),
    "apply_dispatch",
        test([op("is_primitive_function"), reg("fun")]),
        branch(label("primitive_apply")),
        test([op("is_compound_function"), reg("fun")]),
        branch(label("compound_apply")),
        go_to(label("unknown_function_type")),
    "primitive_apply",
        assign("val", [op("apply_primitive_function"), reg("fun"), reg("argl")]),
        restore("continue"),
        go_to(reg("continue")),
    "compound_apply",
        assign("unev", [op("function_parameters"), reg("fun")]),
        assign("env", [op("function_environment"), reg("fun")]),
        assign("env", [op("extend_environment"), reg("unev"), reg("argl"), reg("env")]),
        assign("unev", [op("function_body"), reg("fun")]),
        perform([op("push_marker")]),
        assign("continue", label("return_undefined")),
        go_to(label("ev_dispatch")),
    "ev_return",
        revert_stack_to_marker(),
        restore("continue"),
        assign("comp", [op("return_expression"), reg("comp")]),
        go_to(label("eval_dispatch")),
    "return_undefined",
        perform([op("pop_marker")]),
        restore("continue"),
        assign("val", constant(undefined)),
        go_to(reg("continue")),
    "ev_restore_stack",
        perform([op("pop_marker")]),
        restore("continue"),
        go_to(reg("continue")),
    "ev_block",
        assign("comp", [op("block_body"), reg("comp")]),
        assign("val", [op("scan_out_declarations"), reg("comp")]),
        save("comp"),
        assign("comp", [op("list_of_unassigned"), reg("val")]),
        assign("env", [op("extend_environment"), reg("val"), reg("argl"), reg("env")]),
        restore("comp"),
        go_to(label("eval_dispatch")),
    "ev_assignment",
        assign("unev", [op("assignment_symbol"), reg("comp")]),
        save("unev"),
        assign("comp", [op("assignment_value_expression"), reg("comp")]),
        save("env"),
        save("continue"),
        assign("continue", label("ev_assignment_install")),
    "ev_assignment_install",
        restore("continue"),
        restore("env"),
        restore("unev"),
        perform([op("assign_symbol_value"), reg("unev"), reg("val"), reg("env")]),
        go_to(reg("continue")),
    "ev_function_declaration",
        assign("comp", [op("function_decl_to_constant_decl"), reg("comp")]),
    "ev_declaration",
        assign("unev", [op("declaration_symbol"), reg("comp")]),
        save("unev"),
        assign("comp", [op("declaration_value_expression"), reg("comp")]),
        save("env"),
        save("continue"),
        assign("continue", label("ev_declaration_assign")),
    "ev_declaration_assign",
        restore("continue"),
        restore("env"),
        restore("unev"),
        perform([op("assign_symbol_value"), reg("unev"), reg("val"), reg("env")]),
        assign("val", constant(undefined)),
        go_to(reg("continue")),
    "ev_while",
        perform([op("push_while_marker")]), // Marker for start of while loop
        assign("comp", [op("while_to_application"), reg("comp"), reg("env")]),
        perform([op("push_while_body_start_marker")]), // Marker for start of loop body
        go_to(label("eval_dispatch")),
    "ev_break",
        perform([op("pop_to_while_marker")]),
        assign("val", constant(undefined)),
        go_to(reg("continue")),
    "ev_continue",
        perform([op("pop_to_while_body_start_marker")]),
        go_to(label("ev_while")),
    // ex 5.26
    "primitive_apply",
        assign("argl", [op("force_evaluation"), reg("argl")]),
        assign("val", [op("apply_primitive_function"), reg("fun"), reg("argl")]),
        restore("continue"),
        go_to(reg("continue")),
    "make_thunk",
        save("env"),
        save("comp"),
        assign("val", [op("cons"), op("thunk_symbol"), [op("cons"), reg("comp"), reg("env")]]),
        restore("comp"),
        restore("env"),
        go_to(reg("continue")),
    "force_evaluation_of_args",
        assign("evaluated_args", [op("empty_arglist")]),
        assign("current_arg", [op("first_arg"), reg("argl")]),
    "force_eval_loop",
        test([op("is_thunk"), reg("current_arg")]),
        branch(label("ev_thunk")),
        go_to(label("next_arg")),
    "ev_thunk",
        save("evaluated_args"),
        assign("comp", [op("thunk_expression"), reg("current_arg")]),
        assign("env", [op("thunk_environment"), reg("current_arg")]),
        save("argl"),
        assign("continue", label("ev_thunk_continue")),
        go_to(label("eval_dispatch")),
    "ev_thunk_continue",
        restore("argl"),
        restore("evaluated_args"),
        assign("evaluated_args", [op("adjoin_arg"), reg("val"), reg("evaluated_args")]),
        go_to(label("next_arg")),
    "next_arg",
        assign("argl", [op("rest_args"), reg("argl")]),
        test([op("is_null"), reg("argl")]),
        branch(label("all_args_evaluated")),
        assign("current_arg", [op("first_arg"), reg("argl")]),
        go_to(label("force_eval_loop")),
    "all_args_evaluated",
        assign("argl", reg("evaluated_args")),
        go_to(reg("continue")),
    // end of ex 5.26
    ]
)
