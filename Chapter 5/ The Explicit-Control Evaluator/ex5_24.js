/*
Implement the equivalent of push_marker_to_stack as register-machine instructions,
following the implementation of save and restore in section 5.2.3. Add functions
push_marker and pop_marker to access stacks, mirroring the implementation of
push and pop in section 5.2.1. Note that you do not need to actuallt insert a marker
into the stack. Instead, you can add a local state variable to the stack model to
keep track of the position of the last save before each push_marker_to_stack. If
you choose to put a marker on the stack, see the hint in last exercise
*/

let marker_position = null;
function push_marker() { marker_position = stack.length; }
function pop_marker() {
    if (marker_position === null) {
        throw new Error("No marker on stack");
    } else {
        stack.length = marker_position;
        marker_position = null;
    }
}

controller(
    [
    "eval-dispatch",
        test([op("is_literal"), reg("comp")]),
        branch(label("ev_literal")),
        test([op("is_name"), reg("comp")]),
        branch(label("ev_name")),
        test([op("is_application"), reg("comp")]),
        branch(label("ev_application")),
        test([op("is_operator_conditional"), reg("comp")]),
        branch(label("ev_operator_conditional")),
        test([op("is_conditional"), reg("comp")]),
        branch(label("ev_conditional")),
        test([op("is_lambda"), reg("comp")]),
        branch(label("ev_lambda")),
        test([op("is_sequence"), reg("comp")]),
        branch(label("ev_sequence")),
        test([op("is_block"), reg("comp")]),
        branch(label("ev_block")),
        test([op("is_return_statement"), reg("comp")]),
        branch(label("ev_return")),
        test([op("is_function_declaration"), reg("comp")]),
        branch(label("ev_function_declaration")),
        test([op("is_declaration"), reg("comp")]),
        branch(label("ev_declaration")),
        test([op("is_assignment"), reg("comp")]),
        branch(label("ev_assignment")),
        go_to(label("unknown_compression_type")),
    "ev_literal",
        assign("val", [op("literal_value"), reg("comp")]),
        go_to(reg("continue")),
    "ev_name",
        assign("val", [op("symbol_of_name"), reg("comp"), reg("env")]),
        assign("val", [op("lookup_symbol_value"), reg("val"), reg("env")]),
        go_to(reg("continue")),
    "ev_lambda",
        assign("unev", [op("lambda_parameter_symobls"), reg("comp")]),
        assign("comp", [op("lambda_body"), reg("comp")]),
        assign("val", [op("make_function"), reg("unev"), reg("comp"), reg("env")]),
        go_to(reg("continue")),
    "ev_conditional",
        save(reg("comp")),
        save(reg("env")),
        save(reg("continue")),
        assign("continue", label("ev_conditional_decide")),
        assign("comp", [op("conditional_predicate"), reg("comp")]),
        go_to(label("eval_dispatch")),
    "ev_conditional_decide",
        restore(reg("continue")),
        restore(reg("env")),
        restore(reg("comp")),
        test([op("is_falsy"), reg("val")]),
        branch(label("ev_conditional_alternative")),
    "ev_conditional_consequent",
        assign("comp", [op("conditional_consequent"), reg("comp")]),
        go_to(label("eval_dispatch")),
    "ev_conditional_alternative",
        assign("comp", [op("conditional_alternative"), reg("comp")]),
        go_to(label("eval_dispatch")),
    "ev_sequence",
        assign("unev", [op("sequence_statements"), reg("comp")]),
        test([op("is_seqeuence_empty"), reg("unev")]),
        branch(label("ev_sequence_empty")),
        save("continue"),
    "ev_sequence_next",
        assign("comp", [op("first_statement"), reg("unev")]),
        test([op("is_last_statement"), reg("unev")]),
        branch(label("ev_sequence_last_statement")),
        save("unev"),
        save("env"),
        assign("continue", label("ev_sequence_continue")),
        go_to(label("eval_dispatch")),
    "ev_sequence_continue",
        restore("env"),
        restore("unev"),
        assign("unev", [op("rest_statements"), reg("unev")]),
        go_to(label("ev_sequence_next")),
    "ev_sequence_last_statement",
        restore("continue"),
        go_to(label("continue")),
    "ev_seqeuence_empty",
        assign("val", constant(undefined)),
        go_to(reg("continue")),
    "ev_operator_combination",
        assign("comp", [op("operator_combination_to_application"), reg("comp"), reg("env")]),
    "ev_application",
        save("continue"),
        save("env"),
        assign("unev", [op("operands"), reg("comp")]),
        save("unev"),
        assign("comp", [op("operator"), reg("comp")]),
        assign("continue", label("ev_appl_did_function_expression")),
        go_to(label("eval_dispatch")),
    "ev_appl_did_function_expression",
        restore("unev"), // the operands
        restore("env"),
        assign("argl", [op("empty_arglist")]),
        assign("fun", reg("val")),
        test([op("is_null"), reg("unev")]),
        branch(label("apply_dispatch")),
        save("fun"),
    "ev_appl_argument_expression_loop",
        save("argl"),
        assign("comp", [op("head"), reg("unev")]),
        test([op("is_last_argument_expression"), reg("unev")]),
        branch(label("ev_appl_last_arg")),
        save("env"),
        save("unev"),
        assign("continue", label("ev_appl_accumulate_arg")),
        go_to(label("eval_dispatch")),
    "ev_appl_accumulate_arg",
        restore("unev"),
        restore("env"),
        restore("argl"),
        assign("argl", [op("adjoin_arg"), reg("val"), reg("argl")]),
        assign("unev", [op("tail"), reg("unev")]),
        go_to(label("ev_appl_argument_expression_loop")),
    "ev_appl_last_arg",
        assign("continue", label("ev_appl_accum_last_arg")),
        go_to(label("eval_dispatch")),
    "ev_appl_accum_last_arg",
        restore("argl"),
        assign("argl", [op("adjoin_arg"), reg("val"), reg("argl")]),
        restore("fun"),
        go_to(label("apply_dispatch")),
    "apply_dispatch",
        test([op("is_primitive_function"), reg("fun")]),
        branch(label("primitive_apply")),
        test([op("is_compound_function"), reg("fun")]),
        branch(label("compound_apply")),
        go_to(label("unknown_function_type")),
    "primitive_apply",
        assign("val", [op("apply_primitive_function"), reg("fun"), reg("argl")]),
        restore("continue"),
        go_to(reg("continue")),
    "compound_apply",
        assign("unev", [op("function_parameters"), reg("fun")]),
        assign("env", [op("function_environment"), reg("fun")]),
        assign("env", [op("extend_environment"), reg("unev"), reg("argl"), reg("env")]),
        assign("unev", [op("function_body"), reg("fun")]),
        perform([op("push_marker")]), // ex 5.24
        assign("continue", label("return_undefined")),
        go_to(label("ev_dispatch")),
    "ev_return",
        revert_stack_to_marker(),
        restore("continue"),
        assign("comp", [op("return_expression"), reg("comp")]),
        go_to(label("eval_dispatch")),
    /*
    alternative implementation not tail recursive
    "ev_return",
        assign("comp", [op("return_expression"), reg("comp")]),
        assign("continue", label("ev_restore_stack")),
        go_to(label("eval_dispatch")),
    */
    "return_undefined",
        perform([op("pop_marker")]), // ex 5.24
        restore("continue"),
        assign("val", constant(undefined)),
        go_to(reg("continue")),
    "ev_restore_stack",
        perform([op("pop_marker")]), // ex 5.24
        restore("continue"),
        go_to(reg("continue")),
    ]
)
